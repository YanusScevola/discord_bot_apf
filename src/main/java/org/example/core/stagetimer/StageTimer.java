package org.example.core.stagetimer;import java.awt.Color;import java.util.List;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;import java.util.function.Consumer;import java.util.stream.Collectors;import net.dv8tion.jda.api.EmbedBuilder;import net.dv8tion.jda.api.entities.Message;import net.dv8tion.jda.api.entities.channel.concrete.VoiceChannel;import net.dv8tion.jda.api.interactions.components.buttons.Button;import org.example.resources.Colors;public class StageTimer {    private Timer timer;    private TimerTask currentTask;    private long startTimeMillis;    private long delayTimeMilis;    private long pauseTimeMillis;    private boolean isPaused;    private Message message;    private String title = "";    private String description;    private MessageCallback timerCallback;    private List<Button> buttons;    private final VoiceChannel tribuneVoiceChannel;    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);    private ScheduledFuture<?> delayFuture;    private ScheduledFuture<?> pauseFuture;    @FunctionalInterface    public interface MessageCallback {        void execute(Message message);    }    public StageTimer(VoiceChannel tribuneVoiceChannel) {        this.tribuneVoiceChannel = tribuneVoiceChannel;        this.timer = new Timer();        this.isPaused = false;    }//    private void startSilence() {//        player.playTrack(silentTrack.makeClone());  // Воспроизводим бесшумный трек//    }////    private void stopSilence() {//        player.stopTrack();  // Останавливаем воспроизведение//    }//    public void start(String title, String description, long delayTimeSec, List<Button> buttons, MessageCallback timerCallback) {        this.timerCallback = timerCallback;        this.title = title;        this.description = description;        this.buttons = buttons;        this.startTimeMillis = System.currentTimeMillis();        this.delayTimeMilis = delayTimeSec * 1000L;        String timerText = "Таймер: <t:" + (startTimeMillis / 1000 + delayTimeMilis / 1000) + ":R>";        String userIdText = description.isEmpty() ? "" : description + "\n\n";        EmbedBuilder embedBuilder = new EmbedBuilder();        embedBuilder.setTitle(title).setDescription(userIdText + timerText).setColor(Colors.BLUE);        Consumer<Message> messageConsumer = sentMessage -> {            this.message = sentMessage;            scheduleTimer(delayTimeSec * 1000L, title, description, buttons, (s) -> timerCallback.execute(sentMessage));        };        if (buttons != null && !buttons.isEmpty()) {            tribuneVoiceChannel.sendMessageEmbeds(embedBuilder.build()).setActionRow(buttons).queue(messageConsumer);        } else {            tribuneVoiceChannel.sendMessageEmbeds(embedBuilder.build()).queue(messageConsumer);        }    }    private void scheduleTimer(long delay, String title, String description, List<Button> buttons, MessageCallback timerCallback) {        currentTask = new TimerTask() {            @Override            public void run() {                timerCallback.execute(message);                if (buttons != null && !buttons.isEmpty()) {                    List<Button> disabledButtons = buttons.stream().map(Button::asDisabled).collect(Collectors.toList());                    EmbedBuilder updatedEmbed = new EmbedBuilder();                    String userIdText = description.isEmpty() ? "" : description;                    updatedEmbed.setTitle(title).setDescription(userIdText + " Время вышло!").setColor(Colors.BLUE);                    message.editMessageEmbeds(updatedEmbed.build()).setActionRow(disabledButtons).queue();                } else {                    EmbedBuilder updatedEmbed = new EmbedBuilder();                    updatedEmbed.setTitle(title).setDescription(description + " " + "Время вышло!").setColor(Colors.BLUE);                    message.editMessageEmbeds(updatedEmbed.build()).queue();                }            }        };        timer.schedule(currentTask, delay);    }    public synchronized void pause(long timeSec, long delaySec, Runnable timerCallback) {        if (!isPaused && currentTask != null) {            currentTask.cancel();            isPaused = true;            long currentTimeMillis = System.currentTimeMillis();            long timeElapsedMillis = currentTimeMillis - startTimeMillis;            pauseTimeMillis = Math.max(0, delayTimeMilis - timeElapsedMillis); // Защита от отрицательного времени            long pauseSeconds = pauseTimeMillis / 1000;            String formattedPauseTime;            if (pauseSeconds >= 60) {                long minutes = pauseSeconds / 60;                long seconds = pauseSeconds % 60;                formattedPauseTime = String.format("%d минут %d секунд", minutes, seconds);            } else {                formattedPauseTime = pauseSeconds + " секунд";            }            String staticTimerText = "Остановились на " + formattedPauseTime + ".";            EmbedBuilder embedBuilder = new EmbedBuilder();            embedBuilder.setTitle("(На паузе) " + title).setColor(Color.YELLOW);            embedBuilder.setDescription(staticTimerText);            if (message != null) {                List<Button> disabledButtons = buttons.stream().map(Button::asDisabled).collect(Collectors.toList());                if (!buttons.isEmpty()) {                    message.editMessageEmbeds(embedBuilder.build()).setActionRow(disabledButtons).queue();                } else {                    message.editMessageEmbeds(embedBuilder.build()).queue();                }            }            delayFuture = scheduler.schedule(() -> {                embedBuilder.setColor(Color.YELLOW);                long futureTimeSec = System.currentTimeMillis() / 1000 + timeSec;                String timerText = "Вопрос: <t:" + futureTimeSec + ":R>";                embedBuilder.setDescription(staticTimerText + "\n" + timerText);                if (message != null) {                    message.editMessageEmbeds(embedBuilder.build()).queue();                }                pauseFuture = scheduler.schedule(timerCallback::run, timeSec, TimeUnit.SECONDS);            }, delaySec, TimeUnit.SECONDS);        }    }    public synchronized void resume() {        if (isPaused) {            if (pauseFuture != null) {                pauseFuture.cancel(true);            }            if (delayFuture != null) {                delayFuture.cancel(true);            }            long currentTimeMillis = System.currentTimeMillis();            long resumeTimeSec = (currentTimeMillis + pauseTimeMillis) / 1000;            startTimeMillis = currentTimeMillis - (delayTimeMilis - pauseTimeMillis);            String timerText = "Таймер: <t:" + resumeTimeSec + ":R>";            EmbedBuilder embedBuilder = new EmbedBuilder();            embedBuilder.setTitle("" + title)                    .setDescription(timerText)                    .setColor(Color.BLUE);            if (message != null) {                if (buttons != null && !buttons.isEmpty()) {                    message.editMessageEmbeds(embedBuilder.build())                            .setActionRow(buttons)                            .queue(sentMessage -> {                                scheduleTimer(pauseTimeMillis, title, description, buttons, timerCallback);                            });                } else {                    message.editMessageEmbeds(embedBuilder.build())                            .queue(sentMessage -> {                                scheduleTimer(pauseTimeMillis, title, description, null, timerCallback);                            });                }            }            isPaused = false;        }    }    public synchronized void skip(String description) {        if (currentTask != null && !isPaused) {            currentTask.cancel();            EmbedBuilder updatedEmbed = new EmbedBuilder();            String userIdText = description.isEmpty() ? "" : description;            updatedEmbed.setTitle(title).setDescription(userIdText + " закончил речь досрочно!").setColor(Colors.BLUE);            if (message != null) {                List<Button> disabledButtons = buttons.stream().map(Button::asDisabled).collect(Collectors.toList());                if (!buttons.isEmpty()) {                    message.editMessageEmbeds(updatedEmbed.build()).setActionRow(disabledButtons).queue();                } else {                    message.editMessageEmbeds(updatedEmbed.build()).queue();                }            }            if (timerCallback != null) {                timerCallback.execute(message);            }        }    }    public synchronized long getCurrentTimeLeft() {        long currentTimeMillis = System.currentTimeMillis();        if (isPaused) {            return pauseTimeMillis;        } else {            long timeElapsedMillis = currentTimeMillis - startTimeMillis;            return Math.max(0, delayTimeMilis - timeElapsedMillis);        }    }    public String getTitle() {        return title;    }}