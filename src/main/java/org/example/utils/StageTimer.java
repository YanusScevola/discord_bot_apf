package org.example.utils;import java.awt.Color;import java.util.List;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;import java.util.function.Consumer;import net.dv8tion.jda.api.EmbedBuilder;import net.dv8tion.jda.api.entities.Message;import net.dv8tion.jda.api.entities.channel.concrete.VoiceChannel;import net.dv8tion.jda.api.interactions.components.buttons.Button;public class StageTimer {    private Timer timer;    private TimerTask currentTask;    private long startTimeMillis;    private long delayTimeMilis;    private long pauseTimeMillis;    private boolean isPaused;    private Message message;    private String title = "";    private final VoiceChannel tribuneVoiceChannel;    private Consumer<String> timerCallback;    private List<Button> buttons;    private String staticTimerText = "";    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);    private ScheduledFuture<?> delayFuture;    private ScheduledFuture<?> pauseFuture;    public StageTimer(VoiceChannel tribuneVoiceChannel) {        this.tribuneVoiceChannel = tribuneVoiceChannel;        this.timer = new Timer();        this.isPaused = false;    }    public void start(String title, long delayTimeSec, List<Button> buttons, Consumer<String> timerCallback) {        this.timerCallback = timerCallback;        this.timer = new Timer();        this.title = title;        this.buttons = buttons;        this.startTimeMillis = System.currentTimeMillis();        this.delayTimeMilis = delayTimeSec * 1000L;        String timerText = "Таймер: <t:" + (startTimeMillis / 1000 + delayTimeMilis / 1000) + ":R>";        EmbedBuilder embedBuilder = new EmbedBuilder();        embedBuilder.setTitle(title).setDescription(timerText).setColor(Color.BLUE);        if (buttons != null && !buttons.isEmpty()) {            tribuneVoiceChannel.sendMessageEmbeds(embedBuilder.build()).setActionRow(buttons).queue(sentMessage -> {                this.message = sentMessage;                scheduleTimer(delayTimeSec * 1000L, title, buttons, timerCallback);            });        } else {            tribuneVoiceChannel.sendMessageEmbeds(embedBuilder.build()).queue(sentMessage -> {                this.message = sentMessage;                scheduleTimer(delayTimeSec * 1000L, title, buttons, timerCallback);            });        }    }    private void scheduleTimer(long delay, String title, List<Button> buttons, Consumer<String> timerCallback) {        currentTask = new TimerTask() {            @Override            public void run() {                timerCallback.accept(title);                if (buttons != null && !buttons.isEmpty()) {                    List<Button> disabledButtons = buttons.stream().map(Button::asDisabled).toList();                    EmbedBuilder updatedEmbed = new EmbedBuilder();                    updatedEmbed.setTitle(title).setDescription("Время вышло!").setColor(Color.BLUE);                    message.editMessageEmbeds(updatedEmbed.build()).setActionRow(disabledButtons).queue();                } else {                    EmbedBuilder updatedEmbed = new EmbedBuilder();                    updatedEmbed.setTitle(title).setDescription("Время вышло!").setColor(Color.BLUE);                    message.editMessageEmbeds(updatedEmbed.build()).queue();                }            }        };        timer.schedule(currentTask, delay);    }    public void pause() {        if (!isPaused && currentTask != null) {            currentTask.cancel();  // Отмена текущей задачи таймера            isPaused = true;            long currentTimeMillis = System.currentTimeMillis();            long timeElapsedMillis = (currentTimeMillis - startTimeMillis);            pauseTimeMillis = delayTimeMilis - timeElapsedMillis;            staticTimerText = "Пауза: Осталось " + pauseTimeMillis / 1000 + " секунд.";            EmbedBuilder embedBuilder = new EmbedBuilder();            embedBuilder.setTitle("(На паузе) " + title).setDescription(staticTimerText).setColor(Color.YELLOW);            if (message != null) {                List<Button> disabledButtons = buttons.stream().map(Button::asDisabled).toList(); // Делаем все кнопки неактивными                if (!buttons.isEmpty()) {                    message.editMessageEmbeds(embedBuilder.build()).setActionRow(disabledButtons).queue(); // Обновляем сообщение с неактивными кнопками                } else {                    message.editMessageEmbeds(embedBuilder.build()).queue(); // Обновляем сообщение без кнопок, если их нет                }            }        }    }    public void pause(long timeSec, long delaySec) {        if (!isPaused && currentTask != null) {            currentTask.cancel();            isPaused = true;            long currentTimeMillis = System.currentTimeMillis();            long timeElapsedMillis = (currentTimeMillis - startTimeMillis);            pauseTimeMillis = delayTimeMilis - timeElapsedMillis;            EmbedBuilder embedBuilder = new EmbedBuilder();            embedBuilder.setTitle("(На паузе) " + title).setColor(Color.YELLOW);            String staticTimerText = "Пауза: Остановились на " + pauseTimeMillis / 1000 + " секунде.";            embedBuilder.setDescription(staticTimerText);            if (message != null) {                List<Button> disabledButtons = buttons.stream().map(Button::asDisabled).toList();                if (!buttons.isEmpty()) {                    message.editMessageEmbeds(embedBuilder.build()).setActionRow(disabledButtons).queue();                } else {                    message.editMessageEmbeds(embedBuilder.build()).queue();                }            }            delayFuture = scheduler.schedule(() -> {                embedBuilder.setColor(Color.YELLOW);                String timerText = "Таймер: <t:" + (System.currentTimeMillis() / 1000 + timeSec) + ":R>";                embedBuilder.setDescription(staticTimerText + "\n" + timerText);                if (message != null) {                    message.editMessageEmbeds(embedBuilder.build()).queue();                }                pauseFuture = scheduler.schedule(this::resume, timeSec, TimeUnit.SECONDS);//                pauseFuture = scheduler.schedule(() -> callBack.accept(title), timeSec, TimeUnit.SECONDS);            }, delaySec, TimeUnit.SECONDS);        }    }    public void resume() {        if (isPaused) {            // Отменяем запланированные задачи, если они есть            if (pauseFuture != null) {                pauseFuture.cancel(true);            }            if (delayFuture != null) {                delayFuture.cancel(true);            }            // Рассчитываем время возобновления            long currentTimeMillis = System.currentTimeMillis();            long resumeTimeSec = (currentTimeMillis + pauseTimeMillis) / 1000;            // Создаем текст таймера            String timerText = "Таймер: <t:" + resumeTimeSec + ":R>";            // Создаем и настраиваем EmbedBuilder            EmbedBuilder embedBuilder = new EmbedBuilder();            embedBuilder.setTitle("" + title)                    .setDescription(timerText)                    .setColor(Color.BLUE);            // Обновляем сообщение с новым Embed            if (message != null) {                if (buttons != null && !buttons.isEmpty()) {                    message.editMessageEmbeds(embedBuilder.build())                            .setActionRow(buttons)                            .queue(sentMessage -> {                                // Планируем таймер на оставшееся время                                scheduleTimer(pauseTimeMillis, title, buttons, timerCallback);                            });                } else {                    message.editMessageEmbeds(embedBuilder.build())                            .queue(sentMessage -> {                                // Планируем таймер на оставшееся время                                scheduleTimer(pauseTimeMillis, title, null, timerCallback);                            });                }            }            // Сбрасываем флаг паузы и обновляем переменные            isPaused = false;        }    }    public long getCurrentTimeLeft() {        if (isPaused) {            return pauseTimeMillis;        } else {            long elapsed = System.currentTimeMillis() - (System.currentTimeMillis() - pauseTimeMillis / 1000 * 1000);            return pauseTimeMillis - elapsed;        }    }    public String getTitle() {        return title;    }}