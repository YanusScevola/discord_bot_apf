package org.example.utils;import java.awt.Color;import java.util.List;import java.util.Timer;import java.util.TimerTask;import java.util.function.Consumer;import net.dv8tion.jda.api.EmbedBuilder;import net.dv8tion.jda.api.entities.Message;import net.dv8tion.jda.api.entities.channel.concrete.VoiceChannel;import net.dv8tion.jda.api.interactions.components.buttons.Button;public class StageTimer {    private Timer timer;    private TimerTask currentTask;    private long startTimeMillis;    private long delayTimeMilis;    private long pauseTimeMillis;    private boolean isPaused;    private Message message;    private String title = "";    private final VoiceChannel tribuneVoiceChannel;    private Consumer<String> timerCallback;    private List<Button> buttons;    private String staticTimerText = "";    public StageTimer(VoiceChannel tribuneVoiceChannel) {        this.tribuneVoiceChannel = tribuneVoiceChannel;        this.timer = new Timer();        this.isPaused = false;    }    public void start(String title, long delayTimeSec, List<Button> buttons, Consumer<String> timerCallback) {        this.timerCallback = timerCallback;        this.timer = new Timer();        this.title = title;        this.buttons = buttons;        this.startTimeMillis = System.currentTimeMillis();        this.delayTimeMilis = delayTimeSec * 1000L;        String timerText = "Таймер: <t:" + (startTimeMillis / 1000 + delayTimeMilis / 1000) + ":R>";        EmbedBuilder embedBuilder = new EmbedBuilder();        embedBuilder.setTitle(title).setDescription(timerText).setColor(Color.BLUE);        if (buttons != null && !buttons.isEmpty()) {            tribuneVoiceChannel.sendMessageEmbeds(embedBuilder.build()).setActionRow(buttons).queue(sentMessage -> {                this.message = sentMessage;                scheduleTimer(delayTimeSec * 1000L, title, buttons, timerCallback);            });        } else {            tribuneVoiceChannel.sendMessageEmbeds(embedBuilder.build()).queue(sentMessage -> {                this.message = sentMessage;                scheduleTimer(delayTimeSec * 1000L, title, buttons, timerCallback);            });        }    }    private void scheduleTimer(long delay, String title, List<Button> buttons, Consumer<String> timerCallback) {        currentTask = new TimerTask() {            @Override            public void run() {                timerCallback.accept(title);                if (buttons != null && !buttons.isEmpty()) {                    List<Button> disabledButtons = buttons.stream().map(Button::asDisabled).toList();                    EmbedBuilder updatedEmbed = new EmbedBuilder();                    updatedEmbed.setTitle(title).setDescription("Время вышло!").setColor(Color.BLUE);                    message.editMessageEmbeds(updatedEmbed.build()).setActionRow(disabledButtons).queue();                } else {                    EmbedBuilder updatedEmbed = new EmbedBuilder();                    updatedEmbed.setTitle(title).setDescription("Время вышло!").setColor(Color.BLUE);                    message.editMessageEmbeds(updatedEmbed.build()).queue();                }            }        };        timer.schedule(currentTask, delay);    }    public void pause() {        if (!isPaused && currentTask != null) {            currentTask.cancel();  // Отмена текущей задачи таймера            isPaused = true;            long currentTimeMillis = System.currentTimeMillis();            long timeElapsedMillis = (currentTimeMillis - startTimeMillis) ;            pauseTimeMillis = delayTimeMilis - timeElapsedMillis;            System.out.println("currentTime: " + currentTimeMillis+ "|" + currentTimeMillis / 1000);            System.out.println("startTime: " + startTimeMillis + "|" + startTimeMillis / 1000);            System.out.println("taskTimeSeconds: " + delayTimeMilis + "|" + delayTimeMilis / 1000);            System.out.println("pauseTimeLeft: " + pauseTimeMillis + "|" + pauseTimeMillis / 1000);            System.out.println("timeElapsedSinceStart: " + timeElapsedMillis + "|" + timeElapsedMillis / 1000);            staticTimerText = "Пауза: Осталось " + pauseTimeMillis / 1000 + " секунд.";            EmbedBuilder embedBuilder = new EmbedBuilder();            embedBuilder.setTitle("(На паузе) " + title).setDescription(staticTimerText).setColor(Color.YELLOW);            if (message != null) {                if (buttons != null && !buttons.isEmpty()) {                    message.editMessageEmbeds(embedBuilder.build()).setActionRow(buttons.stream().map(Button::asDisabled).toList()).queue();                } else {                    message.editMessageEmbeds(embedBuilder.build()).queue();                }            }        }    }    public void resume() {        if (isPaused) {            System.out.println("pauseTimeMillis: " + pauseTimeMillis + "|" + pauseTimeMillis / 1000);            long resumeTime =(System.currentTimeMillis() / 1000 + pauseTimeMillis / 1000);            String timerText = "Таймер: <t:" + resumeTime + ":R>";            EmbedBuilder embedBuilder = new EmbedBuilder();            embedBuilder.setTitle(title).setDescription(timerText).setColor(Color.BLUE);            if (buttons != null && !buttons.isEmpty()) {                message.editMessageEmbeds(embedBuilder.build()).setActionRow(buttons).queue(sentMessage -> {                    scheduleTimer(pauseTimeMillis, title, buttons, timerCallback);                });            } else {                message.editMessageEmbeds(embedBuilder.build()).queue(sentMessage -> {                    scheduleTimer(pauseTimeMillis, title, buttons, timerCallback);                });            }            // Сброс флага паузы и обновление переменных            isPaused = false;            staticTimerText = "";        }    }    public long getCurrentTimeLeft() {        if (isPaused) {            return pauseTimeMillis;        } else {            long elapsed = System.currentTimeMillis() - (System.currentTimeMillis() - pauseTimeMillis / 1000 * 1000);            return pauseTimeMillis - elapsed;        }    }    public String getTitle() {        return title;    }}